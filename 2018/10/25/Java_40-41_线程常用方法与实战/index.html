<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="JiaojiaoFu"><link rel="alternative" href="/atom.xml" title="姣姣的个人主页" type="application/atom+xml"><link rel="icon" href="/favicon.png"><title> - 姣姣的个人主页</title><link rel="stylesheet" href="/css/main.css" type="text/css">
<link rel="stylesheet" href="/js/fancybox/jquery.fancybox.min.css" type="text/css">
<!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--><script src="/js/jquery-3.1.1.min.js" type="text/javascript"></script>
<script src="/js/fancybox/jquery.fancybox.min.js" type="text/javascript"></script>
</head><body style="opacity:0"><header class="head"><h1 class="head-title u-fl"><a href="/">姣姣的个人主页</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a class="head-nav__link" href="/archives">カタログ/（目录）</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"> <time class="post__time" datetime="2018-10-24T17:26:10.000Z">October 25, 2018</time><h1 class="post__title"><a href="/2018/10/25/Java_40-41_线程常用方法与实战/"></a></h1><div class="post__main echo"><h3 id="线程常用操作方法">线程常用操作方法</h3>
<h4 id="1-_线程的命名与取得">1. 线程的命名与取得</h4>
<p>线程一般会在其启动之前进行定义，不建议在线程启动后进行更改名称，或者对不同的线程设置重名的操作。</p>
<p>线程名称操作，使用Thread类:</p>
<ul>
<li>构造方法:<code>public Thread(Runnable target,String name)</code></li>
<li>设置名字:<code>public final void setName(String name)</code></li>
<li>取得名字:<code>public final String getName()</code></li>
</ul>
<p>这些方法是Thread类的，而我们的线程类是Runnable的子类。<br>如果想要取得线程的名字，那么我们只能取得当前执行本方法的线程的名字。类中提供一个方法:</p>
<ul>
<li>取得当前线程对象:<code>public static Thread currentThread()</code><br>如果在实例化Thread对象时没有为其设置名字，那么会自动的进行编号命名，保证线程名称不重复。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">package com.company;</div><div class="line">import java.util.concurrent.ExecutionException;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="inheritance"><span class="keyword">implements</span></span> <span class="title">Runnable</span></span>{</div><div class="line"></div><div class="line">    @Override</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> run() {</div><div class="line">        System.out.println(Thread.currentThread().getName());</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFunc</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) throws ExecutionException, InterruptedException {</div><div class="line">        MyThread mt1 = <span class="keyword">new</span> MyThread();</div><div class="line">        <span class="keyword">new</span> Thread(mt1).start();</div><div class="line">        <span class="keyword">new</span> Thread(mt1,<span class="string">"A"</span>).start();</div><div class="line">        <span class="keyword">new</span> Thread(mt1).start();</div><div class="line">        <span class="keyword">new</span> Thread(mt1,<span class="string">"B"</span>).start();</div><div class="line">        <span class="keyword">new</span> Thread(mt1).start();</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>



<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">MyThread mt <span class="subst">=</span> <span class="literal">new</span> MyThread();</div><div class="line"><span class="literal">new</span> <span class="keyword">Thread</span>(mt,<span class="string">"自己的线程"</span>); <span class="comment">//output："自己的线程"</span></div><div class="line">mt<span class="built_in">.</span>run();<span class="comment">//output：main</span></div></pre></td></tr></table></figure>

<p>结论：原来主方法是一个线程(main线程)，所有在主方法上创建的线程都可以将其表示为子线程。<br>每当使用Java命令去解释一个程序类时，对操作系统而言，都相当于启动了一个新进程，而main相当于这个进程的一个子线程。</p>
<p><strong> 提问：</strong>每个JVM启动时都至少要启动几个线程？</p>
<ul>
<li>mian线程：程序的主要执行，以及启动子线程。</li>
<li>gc线程：负责垃圾收集<h4 id="2-_线程的休眠">2. 线程的休眠</h4>
线程的休眠就是让线程的执行速度变得稍微慢一点。休眠方法：</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> sratic <span class="keyword">void</span> <span class="title">sleep</span>(<span class="keyword">long</span> millis) <span class="keyword">throws</span> InterruptedException</div><div class="line">// InterruptedException 代表中断异常，时间是以毫秒 ms 为单位的</div></pre></td></tr></table></figure>

<h4 id="3-_线程优先级">3. 线程优先级</h4>
<p>越高的优先级越<strong>有可能</strong>先执行。Thread 类中提供了两个方法进行优先级操作：</p>
<ul>
<li>设置优先级: <code>public final void setPriority(int newPriority);</code></li>
<li>取得优先级: <code>public int getPriority();</code><br>设置和取得优先级都是使用了 int 数据类型，对此内容有三种取值：</li>
<li>最高优先级: <code>public static final int MAX_PRIORITY, 10</code></li>
<li>中等优先级: <code>public static final int NORM_PRIORITY, 5</code></li>
<li>最低优先级: <code>public static final int MIN_PRIORITY, 1</code></li>
</ul>
<p>主线程是中等优先级 5，<code>Thread.currentThread().getPriority()</code></p>
<h3 id="线程的同步与死锁（了解）">线程的同步与死锁（了解）</h3>
<h4 id="同步问题的引出：">同步问题的引出：</h4>
<p>同步指的是多个线程访问同一资源所需要考虑到的问题。<br>判断与修改数据分开就会造成不同步问题，（判断是否有剩余票 - 休眠 - 修改剩余票数）示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.company;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</div><div class="line"></div><div class="line">class MyThread implements Runnable{</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">5</span>;</div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ;i&lt; <span class="number">100</span> ;i++){</div><div class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.ticket &gt; <span class="number">0</span>) {</div><div class="line">                <span class="keyword">try</span> {</div><div class="line">                    Thread.sleep(<span class="number">100</span>);</div><div class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</div><div class="line">                    e.printStackTrace();</div><div class="line">                }</div><div class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">" 卖票，ticket = "</span>+ <span class="keyword">this</span>.ticket--);</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFunc</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) <span class="keyword">throws</span> ExecutionException, InterruptedException {</div><div class="line">        MyThread mt = <span class="keyword">new</span> MyThread();</div><div class="line">        <span class="keyword">new</span> Thread(mt,<span class="string">"A"</span>).start();</div><div class="line">        <span class="keyword">new</span> Thread(mt,<span class="string">"B"</span>).start();</div><div class="line">        <span class="keyword">new</span> Thread(mt,<span class="string">"C"</span>).start();</div><div class="line">        <span class="keyword">new</span> Thread(mt,<span class="string">"D"</span>).start();</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h4 id="同步操作">同步操作</h4>
<p>可以将（判断是否有剩余票 - 休眠 - 修改剩余票数）封装起来。</p>
<p><img src="2018-10-12-22-14-23.png" alt="解决方法示意图"></p>
<p>Java 中要实现线程的同步可以使用 <strong>synchronized</strong> 关键字。<br>使用方法：</p>
<ul>
<li>同步代码块（Java有四种代码块：普通代码块、构造块、静态块、同步块），必须锁定一个对象。 </li>
<li>同步方法</li>
</ul>
<p>异步操作的执行速度要高于同步操作，但是同步操作时数据安全性较高，属于操作安全的线程操作。</p>
<h4 id="死锁">死锁</h4>
<p>线程同步过多就会造成死锁。</p>
<p><strong>面试题：</strong> 请解释多个线程访问同一资源时需要考虑哪些情况？有可能带来哪些问题？</p>
<ul>
<li>多个线程访问统一资源时一定要处理好同步，可以使用同步代码块或者同步方法；<ul>
<li>同步代码块：synchronized(锁定对象){代码}</li>
<li>同步方法：public synchronized 返回值 方法名称(){代码}</li>
</ul>
</li>
<li>但是过多的使用同步，有可能造成死锁。</li>
</ul>
<h3 id="综合实战：生产者和消费者">综合实战：生产者和消费者</h3>
<p>生产者和消费者之的是两个不同的线程对象，操作统一资源的情况，具体的操作流程如下：</p>
<ul>
<li>生产者负责产生数据，消费者负责取走数据</li>
<li>生产者每生产完一组数据之后，消费者就要取走一组数据</li>
</ul>
<h4 id="等待与唤醒机制">等待与唤醒机制</h4>
<ul>
<li>等待：<code>public final void wait() throws InterruptedException;</code></li>
<li>唤醒第一个等待线程：<code>public final void notify();</code></li>
<li>唤醒全部等待线程，优先级高的先执行：<code>public final void notifyAll()</code><br>以下代码注意的三点：</li>
<li>将 <code>get()</code> 和 <code>set()</code> 设置为同步方法可以解决数据错位问题</li>
<li>增加等待唤醒机制 <code>super.wait()、super.notyfy()</code> 可以保证生产一个，取出一个。</li>
<li>设置标记flag时要初始化，否则默认为false，会取出null-null</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.company;</div><div class="line">class Info{</div><div class="line">    <span class="keyword">private</span> String title;</div><div class="line">    <span class="keyword">private</span> String content;</div><div class="line">    <span class="comment">// flag = true 表示可以生产，但是不可以取走</span></div><div class="line">    <span class="comment">/// flag = false 表示可以取走，但是不可以生产</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;  <span class="comment">//如果不指定flag，默认为false，会取出null-null</span></div><div class="line">    <span class="keyword">public</span> <span class="title">Info</span>() {}</div><div class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">set</span>(String title,String content){</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.flag == <span class="keyword">false</span>){</div><div class="line">            <span class="keyword">try</span> {</div><div class="line">                <span class="keyword">super</span>.wait();</div><div class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</div><div class="line">                e.printStackTrace();</div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="keyword">this</span>.title = title;</div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            Thread.sleep(<span class="number">100</span>);</div><div class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</div><div class="line">            e.printStackTrace();</div><div class="line">        }</div><div class="line">        <span class="keyword">this</span>.content = content;</div><div class="line">        <span class="keyword">this</span>.flag = <span class="keyword">false</span>;      <span class="comment">//修改生产标记</span></div><div class="line">        <span class="keyword">super</span>.notify();         <span class="comment">//唤醒其他等待进程</span></div><div class="line">    }</div><div class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">get</span>(){</div><div class="line">        <span class="keyword">if</span>(flag == <span class="keyword">true</span>){</div><div class="line">            <span class="keyword">try</span> {</div><div class="line">                <span class="keyword">super</span>.wait();</div><div class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</div><div class="line">                e.printStackTrace();</div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            Thread.sleep(<span class="number">100</span>);</div><div class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</div><div class="line">            e.printStackTrace();</div><div class="line">        }</div><div class="line">        System.out.println(<span class="keyword">this</span>.title + <span class="string">" - "</span> + <span class="keyword">this</span>.content);</div><div class="line">        <span class="keyword">this</span>.flag = <span class="keyword">true</span>;       <span class="comment">//修改生产标记</span></div><div class="line">        <span class="keyword">super</span>.notify();         <span class="comment">//唤醒其他等待线程</span></div><div class="line">    }</div><div class="line">}</div><div class="line">class Productor implements Runnable{</div><div class="line">    <span class="keyword">private</span> Info info;</div><div class="line">    <span class="keyword">public</span> <span class="title">Productor</span>(Info info) {</div><div class="line">        <span class="keyword">this</span>.info = info;</div><div class="line">    }</div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; <span class="number">100</span>; i++){</div><div class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>){</div><div class="line">                <span class="keyword">this</span>.info.set(<span class="string">"苏一一"</span>,<span class="string">"大帅哥"</span>);</div><div class="line">            }<span class="keyword">else</span>{</div><div class="line">                <span class="keyword">this</span>.info.set(<span class="string">"姣姣"</span>,<span class="string">"小可爱"</span>);</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line">class Consumer implements Runnable{</div><div class="line">    <span class="keyword">private</span> Info info;</div><div class="line">    <span class="keyword">public</span> <span class="title">Consumer</span>(Info info) {</div><div class="line">        <span class="keyword">this</span>.info = info;</div><div class="line">    }</div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span> ; i++){</div><div class="line">            <span class="keyword">try</span> {</div><div class="line">                Thread.sleep(<span class="number">100</span>);</div><div class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</div><div class="line">                e.printStackTrace();</div><div class="line">            }</div><div class="line">            <span class="keyword">this</span>.info.get();</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestProCon</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String args[]){</div><div class="line">        Info info = <span class="keyword">new</span> Info();</div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Productor(info)).start();</div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Consumer(info)).start();</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>面试题：</strong> 请解释 <code>sleep()</code> 与 <code>wait()</code> 方法的区别</p>
<ul>
<li><code>sleep()</code> 是 <code>Thread</code> 类定义的方法，而 <code>wait()</code> 是 <code>Object</code> 类定义的方法</li>
<li><code>sleep()</code> 可以设置休眠时间，时间一到自动唤醒，而 <code>wait()</code> 需要等待 <code>notify()</code> 进行唤醒</li>
</ul>
</div></header></article><div class="comments" id="lv-container" data-id="city" data-uid="your uid"><script>(function(d, s) {var j, e = d.getElementsByTagName(s)[0];if (typeof LivereTower === 'function') { return; } j = d.createElement(s);j.src = 'https://cdn-city.livere.com/js/embed.dist.js';j.async = true;e.parentNode.insertBefore(j, e);})(document, 'script');</script></div></main><footer class="foot"><div class="foot-copy">&copy; 2016-2018 JiaojiaoFu</div></footer><script src="/js/scroller.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>
</body></html>