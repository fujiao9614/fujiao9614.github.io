<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="JiaojiaoFu"><link rel="alternative" href="/atom.xml" title="姣姣的个人主页" type="application/atom+xml"><link rel="icon" href="/favicon.png"><title>Chapter 47 反射机制 - 姣姣的个人主页</title><link rel="stylesheet" href="/css/main.css" type="text/css">
<link rel="stylesheet" href="/js/fancybox/jquery.fancybox.min.css" type="text/css">
<!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--><script src="/js/jquery-3.1.1.min.js" type="text/javascript"></script>
<script src="/js/fancybox/jquery.fancybox.min.js" type="text/javascript"></script>
</head><body style="opacity:0"><header class="head"><h1 class="head-title u-fl"><a href="/">姣姣的个人主页</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a class="head-nav__link" href="/archives">カタログ/（目录）</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"> <time class="post__time" datetime="2018-10-23T16:00:00.000Z">October 24, 2018</time><h1 class="post__title"><a href="/2018/10/24/Java_47_反射机制/">Chapter 47 反射机制</a></h1><div class="post__main echo"><p>认识反射机制，反射实例化对象，使用反射调用构造，反射调用方法举例<br><a id="more"></a></p>
<h3 id="反射机制">反射机制</h3>
<h4 id="1-_认识反射机制">1. 认识反射机制</h4>
<p>反：通过对象找到出处，在 Object 类里面会提供一个方法：</p>
<ul>
<li>取得 class 对象:<code>public final Class&lt;T&gt; getClass()</code><br><strong>示例</strong>: 取得 class 对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Date;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] agrs) {</div><div class="line">        Date date = <span class="keyword">new</span> Date();</div><div class="line">        <span class="comment">// 输出：class java.util.Date</span></div><div class="line">        System.out.println(date.getClass());</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>对象调用 getClass() 方法后输出了类的完整名称，等于是找到了对象的出处，称为”反“。</p>
<h4 id="2-_Class_类对象实例化">2. Class 类对象实例化</h4>
<p>java.lang.Class 是一个类，这个类是反射类的源头，，即所有的反射类都要从此类开始，这个类有三种实例化方式：</p>
<ul>
<li>第一种：调用 Object 类中的 getClass() 方法。使用频率很低。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Date;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] agrs) {</div><div class="line">        Date date = <span class="keyword">new</span> Date();</div><div class="line">        Class&lt;?&gt; cla = date.getClass();</div><div class="line">        <span class="comment">// 输出： class java.util.Date</span></div><div class="line">        System.out.println(cla);</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<ul>
<li>第二种：使用”类.class“ 取得，以后讲解 Hibemat、MyBatis、Spring 等使用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Date;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] agrs) {</div><div class="line">        Class&lt;?&gt; cla = Date.class;</div><div class="line">        <span class="comment">// 输出： class java.util.Date</span></div><div class="line">        System.out.println(cla);</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>之前的方法是产生了类的实例化对象之后取得的 Class 类对象，这个方法没有实例化对象。</p>
<ul>
<li>第三种：调用 Class 类提供的一个方法（重要）<br>实例化 Class 类对象：<code>public static Class&lt;?&gt;forName(String className)throws ClassNotFoundException</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] agrs) {</div><div class="line">        Class&lt;?&gt; cla = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            cla = Class.forName(<span class="string">"java.util.Date"</span>);</div><div class="line">        } <span class="keyword">catch</span> (ClassNotFoundException e) {</div><div class="line">            e.printStackTrace();</div><div class="line">        }</div><div class="line">        <span class="comment">// 输出： class java.util.Date</span></div><div class="line">        System.out.println(cla);</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>异常的处理方式不同：这个更简洁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] agrs) <span class="keyword">throws</span> Exception{</div><div class="line">        Class&lt;?&gt; cla = <span class="keyword">null</span>;</div><div class="line">        cla = Class.forName(<span class="string">"java.util.Date"</span>);</div><div class="line">        <span class="comment">// 输出： class java.util.Date</span></div><div class="line">        System.out.println(cla);</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>可以发现该方法不使用 import 语句导入一个明确的类，类名称是采用字符串的形式描述的。</p>
<h4 id="3-_反射实例化对象">3. 反射实例化对象</h4>
<p>使用反射类来实例化对象操作：</p>
<ul>
<li>实例化对象方法：<code>public T newInstance() throws XXXException</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] agrs) <span class="keyword">throws</span> Exception{</div><div class="line">        Class&lt;?&gt; cla = Class.forName(<span class="string">"com.company.Book"</span>);</div><div class="line">        Object obj = cla.newInstance();</div><div class="line">        Book book = (Book) obj;</div><div class="line">        <span class="comment">// 输出 obj 和 book 结果是一样的</span></div><div class="line">        <span class="comment">//System.out.println(obj);</span></div><div class="line">        System.out.println(book);</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>有了反射之后，以后进行对象实例化操作不再只是单独的依靠关键字 new 了，但这并不表示关键字 new 被完全代替了。<br>new 是造成耦合的最大元凶，一切耦合都起源于 new。<br><strong>范例</strong>：观察工厂设计模式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.company;</div><div class="line">interface Fruit{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span>();</div><div class="line">}</div><div class="line"></div><div class="line">class Apple implements Fruit{</div><div class="line">    <span class="keyword">public</span> <span class="title">Apple</span>() {</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span>() {</div><div class="line">        System.out.println(<span class="string">"*** 吃苹果"</span>);</div><div class="line">    }</div><div class="line">}</div><div class="line">class Factory{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Fruit <span class="title">getInstance</span>(String className){</div><div class="line">        <span class="keyword">if</span>(<span class="string">"apple"</span>.equals(className)){</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Apple();</div><div class="line">        }</div><div class="line">        <span class="keyword">else</span> {</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFactory</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args){</div><div class="line">        Fruit f = Factory.getInstance(<span class="string">"apple"</span>);</div><div class="line">        f.eat();</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>每增加一个类就要修改工厂类，因为工厂类中的对象都是通过关键 new 直接实例化的，new 就成为所有问题的关键点。<br>想要解决这一问题，就要依靠反射完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.company;</div><div class="line">interface Fruit{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span>();</div><div class="line">}</div><div class="line">class Apple implements Fruit{</div><div class="line">    <span class="keyword">public</span> <span class="title">Apple</span>() {</div><div class="line">    }</div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span>() {</div><div class="line">        System.out.println(<span class="string">"*** 吃苹果"</span>);</div><div class="line">    }</div><div class="line">}</div><div class="line">class Orange implements Fruit{</div><div class="line">    <span class="keyword">public</span> <span class="title">Orange</span>() {</div><div class="line">    }</div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span>() {</div><div class="line">        System.out.println(<span class="string">"*** 吃橘子"</span>);</div><div class="line">    }</div><div class="line">}</div><div class="line">class Factory{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Fruit <span class="title">getInstance</span>(String className){</div><div class="line">        Fruit f = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            f = (Fruit) Class.forName(className).newInstance();</div><div class="line">        } <span class="keyword">catch</span> (InstantiationException e) {</div><div class="line">            e.printStackTrace();</div><div class="line">        } <span class="keyword">catch</span> (IllegalAccessException e) {</div><div class="line">            e.printStackTrace();</div><div class="line">        } <span class="keyword">catch</span> (ClassNotFoundException e) {</div><div class="line">            e.printStackTrace();</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> f;</div><div class="line">    }</div><div class="line">}</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFactory</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args){</div><div class="line">        <span class="comment">//Fruit f = Factory.getInstance("com.company.Apple");</span></div><div class="line">        Fruit f = Factory.getInstance(<span class="string">"com.company.Orange"</span>);</div><div class="line">        f.eat();</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>此时的程序真正完成了解耦合的目的，可扩展性非常强。</p>
<h4 id="4-_使用反射调用构造">4. 使用反射调用构造</h4>
<p>以上反射机制实例化对象的方法都是使用无参构造，若类中没有无参构造，程序则会抛出 NoSuchMethodException 异常。这种情况下只能明确的调用有参方法。<br>Class 类提供了一个方法可以取得构造</p>
<ul>
<li>取出全部构造：<code>public Constructor&lt;?&gt;[] getConstructors() throws XXXException</code></li>
<li>取得一个指定参数顺序的构造<code>public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes) throws NoSuchMethodException</code><br>以上两个方法返回的都是 “java.lang.reflect.Constructor” 类对象,这个类中提供一个明确传递有参内容的实例化对象方法，<code>public T newInstance(Object ... initargs) throws XXXException</code><br><strong>示例</strong>：明确调用类中的有参构造</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.company;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] agrs) <span class="keyword">throws</span> Exception{</div><div class="line">        Class&lt;?&gt; cla = Class.forName(<span class="string">"com.mldn.demo.Book"</span>);</div><div class="line">        <span class="comment">//public Book(String title, double price)</span></div><div class="line">        Constructor&lt;?&gt; con = cla.getConstructor(String.class,<span class="keyword">double</span>.class);</div><div class="line">        Object obj = con.newInstance(<span class="string">"Java开发"</span>,<span class="number">79.8</span>);    <span class="comment">// 实例化对象</span></div><div class="line">        System.out.println(obj);</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>此操作很麻烦，所以前面说过：简单 Java 类的开发中不管有多少个构造方法，请至少保留无参构造方法</p>
<h4 id="5-_反射调用方法">5. 反射调用方法</h4>
<p>类中的普通方法只有在一个类产生实例化对象之后才能调用，实例化对象的方式有三个： new，克隆，反射。<br>Class 类中提供一下取得类中 Method 的操作</p>
<ul>
<li>取得一个类中的全部方法：<code>public Method[] getMethods() throws XXXEcxeption</code></li>
<li>取得指定方法：<code>public Method getMethod(String name,Class&lt;?&gt; ...parameterType) throws XXXException</code>    </li>
</ul>
<p>以上两个方法返回的都是 “java.lang.reflect.Method” 类的对象，这个类中重点关注一个方法：</p>
<ul>
<li>调用方法：<code>public Object invoke(Object obj,Object... args) throws XXXException</code>  </li>
</ul>
<p><strong>示例</strong>：反射调用方法<br>定义Book类，其中包括无参构造方法、属性 title 和 price 的 setter 和 getter方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.company;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.lang.reflect.Method;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] agrs) <span class="keyword">throws</span> Exception{</div><div class="line">        String fieldName = <span class="string">"title"</span>;     <span class="comment">// 要操作的成员</span></div><div class="line">        Class&lt;?&gt; cla = Class.forName(<span class="string">"com.mldn.demo.Book"</span>);</div><div class="line">        Object obj = cla.newInstance();         <span class="comment">// 必须给出实例化对象</span></div><div class="line"></div><div class="line">        Method getMet = cla.getMethod(<span class="string">"get"</span> + initcap(fieldName));</div><div class="line">        Method setMet = cla.getMethod(<span class="string">"set"</span> + initcap(fieldName),String.class);</div><div class="line"></div><div class="line">        setMet.invoke(obj,<span class="string">"Java开发"</span>);        <span class="comment">// 等价于 Book类对象.setTitle("Java开发")</span></div><div class="line">        System.out.println(getMet.invoke(obj));</div><div class="line">    }</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">initcap</span>(String str){ <span class="comment">// 首字母大写</span></div><div class="line">        <span class="keyword">return</span> str.substring(<span class="number">0</span>,<span class="number">1</span>).toUpperCase() + str.substring(<span class="number">1</span>);</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>此时完全看不到具体的操作类型，即利用反射可以实现任意类的指定方法调用。</p>
<h4 id="6-_反射调用成员">6. 反射调用成员</h4>
<p>类中的属性一定要在本类实例化对象产生之后才可以分配内存空间。Class 类中提供取得成员的方法：</p>
<ul>
<li>取得全部成员：<code>public Field[] getDeclaredFields() throws SecurityException</code></li>
<li>取得指定成员：<code>public Field getDeclaredField(String name) throws NoSunFieldException,SecurityException</code><br>返回的类型是 java.lang.reflect.Field 类，这个类中有两个重要方法：</li>
<li>取得属性内容：<code>public Object get(Object obj) throws XXXException</code></li>
<li>设置属性内容：<code>public void set(Object obj,Object value) throws XXXException</code></li>
</ul>
<p>在 Field 的父类 <code>java.util.reflect.AccessibleObject</code>类下面(JDK 1.8 之后修改)：</p>
<ul>
<li>Executable：下面继承了 Constructor,Method;</li>
<li>Field<br>这个类中提供了一个方法：<code>public void setAccessible(bool flag) throws XXXException</code><br><strong><em>注意</em></strong>：如果不使用此方法取消封装，那么将无法访问私有属性</li>
</ul>
<p><strong>示例</strong>：提供 Book 类，类中有 private String title 属性，使用反射调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.company;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.lang.reflect.Field;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] agrs) <span class="keyword">throws</span> Exception{</div><div class="line">        String fieldName = <span class="string">"title"</span>;  <span class="comment">// 要操作的成员</span></div><div class="line">        Class&lt;?&gt; cla = Class.forName(<span class="string">"com.mldn.demo.Book"</span>);</div><div class="line">        Object obj = cla.newInstance();  <span class="comment">// 必须给出实例化对象</span></div><div class="line">        Field titleField = cla.getDeclaredField(fieldName);</div><div class="line">        titleField.setAccessible(<span class="keyword">true</span>);   <span class="comment">// 封装取消了</span></div><div class="line">        titleField.set(obj,<span class="string">"Java开发"</span>);   <span class="comment">// 相当于 Book类对象.titile = "Java开发"</span></div><div class="line">        System.out.println(titleField.get(obj));  <span class="comment">// 相当于Book类对象.title</span></div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>构造方法和普通方法同样也可以取消封装，只不过很少这样做，对于属性的访问最好使用 setter、getter 方法。</p>
</div></header><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a class="post__tag__link" href="/tags/Java/">Java</a></li></ul></footer></article><div class="comments" id="lv-container" data-id="city" data-uid="your uid"><script>(function(d, s) {var j, e = d.getElementsByTagName(s)[0];if (typeof LivereTower === 'function') { return; } j = d.createElement(s);j.src = 'https://cdn-city.livere.com/js/embed.dist.js';j.async = true;e.parentNode.insertBefore(j, e);})(document, 'script');</script></div></main><footer class="foot"><div class="foot-copy">&copy; 2016-2018 JiaojiaoFu</div></footer><script src="/js/scroller.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>
</body></html>