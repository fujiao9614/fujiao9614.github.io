<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="JiaojiaoFu"><link rel="alternative" href="/atom.xml" title="姣姣的个人主页" type="application/atom+xml"><link rel="icon" href="/favicon.png"><title>比较器 - 姣姣的个人主页</title><link rel="stylesheet" href="/css/main.css" type="text/css">
<link rel="stylesheet" href="/js/fancybox/jquery.fancybox.min.css" type="text/css">
<!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--><script src="/js/jquery-3.1.1.min.js" type="text/javascript"></script>
<script src="/js/fancybox/jquery.fancybox.min.js" type="text/javascript"></script>
</head><body style="opacity:0"><header class="head"><h1 class="head-title u-fl"><a href="/">姣姣的个人主页</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a class="head-nav__link" href="/archives">カタログ/（目录）</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"> <time class="post__time" datetime="2018-10-23T16:00:00.000Z">October 24, 2018</time><h1 class="post__title"><a href="/2018/10/24/Java_45_比较器/">比较器</a></h1><div class="post__main echo"><p>学习使用比较器 Comparable 接口。<br><a id="more"></a></p>
<h3 id="比较器">比较器</h3>
<h4 id="1-_Arrays_类（了解）">1. Arrays 类（了解）</h4>
<p>之前使用的 <code>java.util.Arrays.sort()</code>可以实现数组的排序，Arrays 是 java.util 包中提供的工具类，主要完成与数组有关的操作功能。   </p>
<ol>
<li>该类提供了二分查找方法：<code>public static int binarySearch(数据类型[] a, 数据类型 key)</code>，二分查找的前提：<strong>数组有序</strong><br><strong>示例：</strong>二分查找的实现</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Arrays;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] agrs)  {</div><div class="line">        <span class="keyword">int</span>[] data = <span class="keyword">new</span> <span class="keyword">int</span>[]{<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">10</span>};</div><div class="line">        java.util.Arrays.sort(data);</div><div class="line">        <span class="comment">// 输出 5 ，非负表示查找到了</span></div><div class="line">        System.out.println(Arrays.binarySearch(data,<span class="number">9</span>)); </div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<ol start="2">
<li>提供了数组比较： <code>public static boolean equals(数据类型[] a,数据类型[] b)</code>, <strong><em>注意</em></strong> 与 Object 类中的 equals() 方法无关。<br>要想判断数组是否相同，需要顺序完全一致<br><strong>示例：</strong> 判断数组是否相等</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Arrays;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] agrs)  {</div><div class="line">        <span class="keyword">int</span>[] dataA = <span class="keyword">new</span> <span class="keyword">int</span>[]{<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>};</div><div class="line">        <span class="keyword">int</span>[] dataB = <span class="keyword">new</span> <span class="keyword">int</span>[]{<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>};</div><div class="line">        <span class="comment">// dataA 与 dataB 数据相同且顺序相同输出 true，否则输出false</span></div><div class="line">        System.out.println(Arrays.equals(dataA,dataB)); </div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<ol start="3">
<li>其他操作：</li>
</ol>
<ul>
<li>填充数组: <code>public static void fill(数据类型[] a, 数据类型 val)</code>;</li>
<li>将数组变为字符串输出：<code>public static String toString(数据类型[] a)</code>。<br><strong>举例：</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Arrays;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] agrs) {</div><div class="line">        <span class="keyword">int</span>[] data = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</div><div class="line">        Arrays.fill(data, <span class="number">5</span>);</div><div class="line">        <span class="comment">// 输出：[5, 5, 5, 5, 5, 5, 5, 5, 5, 5]</span></div><div class="line">        System.out.println(Arrays.toString(data));</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h4 id="2-_比较器_Comparable（核心）">2. 比较器 Comparable（核心）</h4>
<p>比较的规则是由 Comparable 接口定义的，接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;</span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span>(T o);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>实际上，String 类就是 Comparable 接口的子类，之前使用的 compareTo() 方法就是比较的操作功能。建议 compareTo() 返回三类数据： 1（）大于、0（等于）、-1（小于）。<br>compareTo() 方法由 Array.sort() 自动调用。只需要覆写 compareTo 方法即可。<br><strong>示例：</strong> 比较器的使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Arrays;</div><div class="line">class Book implements Comparable&lt;Book&gt;{</div><div class="line">    <span class="keyword">private</span> String title;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">double</span> price;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="title">Book</span>(String title, <span class="keyword">double</span> price) {</div><div class="line">        <span class="keyword">this</span>.title = title;</div><div class="line">        <span class="keyword">this</span>.price = price;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> String <span class="title">toString</span>() {</div><div class="line">        <span class="keyword">return</span> <span class="string">"书名："</span> + <span class="keyword">this</span>.title + <span class="string">"、价格："</span> + <span class="keyword">this</span>.price + <span class="string">"\n"</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span>(Book o) {</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.price &gt; o.price){</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        }</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.price == o.price){</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        }</div><div class="line">        <span class="keyword">else</span>{</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] agrs) {</div><div class="line">        Book[] books = <span class="keyword">new</span> Book[]{</div><div class="line">                <span class="keyword">new</span> Book(<span class="string">"Java开发"</span>,<span class="number">79.8</span>),</div><div class="line">                <span class="keyword">new</span> Book(<span class="string">"JSP开发"</span>,<span class="number">69.8</span>),</div><div class="line">                <span class="keyword">new</span> Book(<span class="string">"Oracle开发"</span>,<span class="number">99.8</span>),</div><div class="line">                <span class="keyword">new</span> Book(<span class="string">"Android开发"</span>,<span class="number">89.8</span>)</div><div class="line">        };</div><div class="line">        Arrays.sort(books);</div><div class="line"><span class="comment">//       输出： [书名：JSP开发、价格：69.8</span></div><div class="line"><span class="comment">//                , 书名：Java开发、价格：79.8</span></div><div class="line"><span class="comment">//                , 书名：Android开发、价格：89.8</span></div><div class="line"><span class="comment">//                , 书名：Oracle开发、价格：99.8</span></div><div class="line"><span class="comment">//              ]   </span></div><div class="line">        System.out.println(Arrays.toString(books));</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong><em>总结：</em></strong> 在任何情况下，一组对象要排序，那么对象所在的类一定要实现 Comparable 接口。</p>
<h4 id="3-_二叉树的实现_-_BinaryTree_(了解)">3. 二叉树的实现 - BinaryTree (了解)</h4>
<p>树是一种比链表更为复杂的概念应用，本质也属于动态对象数组，与链表不同：树的最大特征是可以根据数据进行排序。<br>树的操作原理：选择第一个数据作为根节点，比根节点小的数据放在左子树（左节点），比根节点大的数据放在右子树（右节点），取的时候按照中序遍历的方式取出（左-中-右）。<br>任何数据的 Node 类的核心功能是保存真实数据和配置节点关系。  </p>
<p><strong>示例：</strong> 定义二叉树  </p>
<ul>
<li>定义出要使用的数据，数据所在的类需要实现 Comparable 接口； </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">class Book implements Comparable&lt;Book&gt;{</div><div class="line">    <span class="keyword">private</span> String title;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">double</span> price;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="title">Book</span>(String title, <span class="keyword">double</span> price) {</div><div class="line">        <span class="keyword">this</span>.title = title;</div><div class="line">        <span class="keyword">this</span>.price = price;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> String <span class="title">toString</span>() {</div><div class="line">        <span class="keyword">return</span> <span class="string">"书名："</span> + <span class="keyword">this</span>.title + <span class="string">"、价格："</span> + <span class="keyword">this</span>.price + <span class="string">"\n"</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span>(Book o) {</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.price &gt; o.price){</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        }</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.price == o.price){</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        }</div><div class="line">        <span class="keyword">else</span>{</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<ul>
<li>定义二叉树，所有的数据结构都需要有 Node 类的支持。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line">class BinaryTree{</div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>{</div><div class="line">        <span class="keyword">private</span> Comparable data;    <span class="comment">// 排序的依据就是 Comparable</span></div><div class="line">        <span class="keyword">private</span> Node left;      <span class="comment">// 保存左节点</span></div><div class="line">        <span class="keyword">private</span> Node right;     <span class="comment">// 保存右节点</span></div><div class="line">        <span class="keyword">public</span> <span class="title">Node</span>(Comparable data) {</div><div class="line">            <span class="keyword">this</span>.data = data;</div><div class="line">        }</div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNode</span>(Node newNode){</div><div class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.data.compareTo(newNode.data) &gt; <span class="number">0</span>){</div><div class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.left == <span class="keyword">null</span>){</div><div class="line">                    <span class="keyword">this</span>.left = newNode;</div><div class="line">                }</div><div class="line">                <span class="keyword">else</span>{</div><div class="line">                    <span class="keyword">this</span>.left.addNode(newNode);</div><div class="line">                }</div><div class="line">            }</div><div class="line">            <span class="keyword">else</span>{</div><div class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.right == <span class="keyword">null</span>){</div><div class="line">                    <span class="keyword">this</span>.right = newNode;</div><div class="line">                }</div><div class="line">                <span class="keyword">else</span>{</div><div class="line">                    <span class="keyword">this</span>.right.addNode(newNode);</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toArrayNode</span>(){</div><div class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span>){      <span class="comment">// 表示有左节点</span></div><div class="line">                <span class="keyword">this</span>.left.toArrayNode();</div><div class="line">            }</div><div class="line">            BinaryTree.<span class="keyword">this</span>.retDate[BinaryTree.<span class="keyword">this</span>.foot++] = <span class="keyword">this</span>.data;</div><div class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span>){     <span class="comment">// 右子树输出</span></div><div class="line">                <span class="keyword">this</span>.right.toArrayNode();</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Node root;      <span class="comment">// 定义根节点</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;  <span class="comment">// 定义二叉树节点个数</span></div><div class="line">    <span class="keyword">private</span> Object[] retDate;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> foot = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span>(Object obj){    <span class="comment">// 进行数据追加</span></div><div class="line">        Comparable com = (Comparable) obj;  <span class="comment">// 必须变为 Comparable 才可以实现 Node 保存</span></div><div class="line">        Node newNode = <span class="keyword">new</span> Node(com);   <span class="comment">// 创建新节点</span></div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.root == <span class="keyword">null</span>){          <span class="comment">// 现在不存在根节点</span></div><div class="line">            <span class="keyword">this</span>.root = newNode;        <span class="comment">// 保存根节点</span></div><div class="line">        }</div><div class="line">        <span class="keyword">else</span>{</div><div class="line">            <span class="keyword">this</span>.root.addNode(newNode);     <span class="comment">// 交给 Node 类处理</span></div><div class="line">        }</div><div class="line">        <span class="keyword">this</span>.count ++;      <span class="comment">// 追加成功，二叉树的节点个数增加</span></div><div class="line">    }</div><div class="line">    <span class="keyword">public</span> Object[] <span class="title">toArray</span>(){</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.root == <span class="keyword">null</span>){</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        }</div><div class="line">        <span class="keyword">this</span>.foot = <span class="number">0</span>;</div><div class="line">        <span class="keyword">this</span>.retDate = <span class="keyword">new</span> Object[count];</div><div class="line">        <span class="keyword">this</span>.root.toArrayNode();</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.retDate;</div><div class="line">    }</div><div class="line"></div><div class="line">}</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] agrs) {</div><div class="line"></div><div class="line">        BinaryTree bt = <span class="keyword">new</span> BinaryTree();</div><div class="line">        bt.add(<span class="keyword">new</span> Book(<span class="string">"Java开发"</span>,<span class="number">79.8</span>));</div><div class="line">        bt.add(<span class="keyword">new</span> Book(<span class="string">"JSP开发"</span>,<span class="number">69.8</span>));</div><div class="line">        bt.add(<span class="keyword">new</span> Book(<span class="string">"Oracle开发"</span>,<span class="number">99.8</span>));</div><div class="line">        bt.add(<span class="keyword">new</span> Book(<span class="string">"Android开发"</span>,<span class="number">89.8</span>));</div><div class="line">        <span class="comment">//下面两行和最后一行等价</span></div><div class="line"><span class="comment">//        Object[] obj = bt.toArray();</span></div><div class="line"><span class="comment">//        System.out.println(Arrays.toString(obj));</span></div><div class="line">        System.out.println(Arrays.toString(bt.toArray()));</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>以上这些内容，Java 的类库都有自己的实现。</p>
<h4 id="挽救的比较器：Comparator_接口（了解，基本不使用）">挽救的比较器：Comparator 接口（了解，基本不使用）</h4>
<p>由于设置初期没有安排某类对象数组的排序（该类没有实现 Comparable 接口），在不改变该类的情况下，如何实现对象数组排序功能。针对该问题，Java 提供了一个比较器： java.util.Comparator。<br>原本的 Comparator 中定义了两个方法：只需要实现其中的 compare() 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@FunctionalInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt;</span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span>(T o1, T o2);</div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span>(Object obj);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>解决方法：单独准备一个类来实现 Comparator 接口，这个类将作为指定类的排序类。<br><strong>范例：</strong> 定义排序的工具类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line">之前使用 Comparable 接口是利用的是 Arrays.sort() 方法，现在我们使用另一个被重载的 sort() 方法。  </div><div class="line">`<span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title">sort</span>(T[] a,Comparable &lt;? <span class="keyword">super</span> T&gt; c)`  </div><div class="line">(&lt;? <span class="keyword">super</span> T&gt;设置了泛型的下限，找的一定是 Book 类或者它的父类)  </div><div class="line">**示例**：实现对象数组的排序</div></pre></td></tr></table></figure>

<p> java<br>public class TestDemo {<br>    public static void main(String[] agrs) {<br>        Book[] books = new Book[]{<br>                new Book(“Java开发”,79.8),<br>                new Book(“JSP开发”,69.8),<br>                new Book(“Oracle开发”,99.8),<br>                new Book(“Android开发”,89.8)<br>        };<br>        Arrays.sort(books,new BookComparator());<br>        System.out.println(Arrays.toString(books));<br>    }<br>}<br><code>`</code><br>可以看出，Comparator 实现对象数组排序较为麻烦，需要定义一个专门的排序类并且指明一个排序规则类。</p>
<p><strong><em>问题</em></strong> ：请解释两种比较器的区别（Comparable 和 Comparator）</p>
<ul>
<li>如果对象数组要进行排序那么必须设置排序规则，可以使用 Comparator 或 Comparable。</li>
<li>java.util.Comparable 是一个在类定义时实现好的接口，这样本类对象数组就可以进行排序，在 Comparable 接口下定义有 public int compareTo() 方法；</li>
<li>java.util.Comparator 是专门定义一个类的比较规则，属于挽救的比较操作，其中有两个方法 compare() 和 equals()。equals()方法一般不关注。</li>
</ul>
</div></header><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a class="post__tag__link" href="/tags/Java/">Java</a></li></ul></footer></article><div class="comments" id="lv-container" data-id="city" data-uid="your uid"><script>(function(d, s) {var j, e = d.getElementsByTagName(s)[0];if (typeof LivereTower === 'function') { return; } j = d.createElement(s);j.src = 'https://cdn-city.livere.com/js/embed.dist.js';j.async = true;e.parentNode.insertBefore(j, e);})(document, 'script');</script></div></main><footer class="foot"><div class="foot-copy">&copy; 2016-2018 JiaojiaoFu</div></footer><script src="/js/scroller.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>
</body></html>